#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <cmath>
#include <vector>
#include <unistd.h>
#include <getopt.h>
#include <cstring>

#include "TFile.h"
#include "TTree.h"
#include "TH1F.h"
#include "TString.h"
#include "TNtuple.h"
#include "TChain.h"
#include "TMath.h"
#include "TSystem.h"
#include "TMatrixT.h"
#include "TRandom3.h"
#include "TError.h"
#include "TCanvas.h"
#include "TH2F.h"
#include "TGraph.h"
#include "TLorentzVector.h"
#include "TVector3.h"
#include "TMath.h"
#include "Math/ProbFuncMathCore.h"
#include "Math/PdfFuncMathCore.h"
#include "TLine.h"

#include "params.h"
#include "SBNconfig.h"
#include "SBNchi.h"
#include "SBNspec.h"
#include "SBNosc.h"
#include "SBNfit.h"
#include "SBNfit3pN.h"


#include "SBNcovar.h"

#define no_argument 0
#define required_argument 1
#define optional_argument 2

using namespace sbn;

double cdf(double x, int k){
	double ko2 = (double)k/2.0;
	double gammafunction = TMath::Gamma(ko2);
	double uppergammafunction = TMath::Gamma(ko2,x/2);
	double lowergammafunction = gammafunction-uppergammafunction;

//	return lowergammafunction/gammafunction;
	return ROOT::Math::chisquared_cdf(x,(double)k);	

}


/*************************************************************
 *************************************************************
 *		BEGIN example.cxx
 ************************************************************
 ************************************************************/
int main(int argc, char* argv[])
{


	std::string xml = "default.xml";
	int iarg = 0;
	opterr=1;
	int index; 
	int test_mode=0;
	std::string filename = "default.root";
	/*************************************************************
	 *************************************************************
	 *		Command Line Argument Reading
	 ************************************************************
	 ************************************************************/

	const struct option longopts[] = 
	{
		{"xml", 		required_argument, 	0, 'x'},
		{"test",		required_argument,	0, 't'},
		{"file",		required_argument,	0, 'f'},
		{0,			no_argument, 		0,  0},
	};


	while(iarg != -1)
	{
		iarg = getopt_long(argc,argv, "x:t:f:", longopts, &index);

		switch(iarg)
		{
			case 'x':
				xml = optarg;
				break;
			case 'f':
				filename = optarg;//`strtof(optarg,NULL);
				break;

			case 't':
				test_mode = strtof(optarg,NULL);
				break;
			case '?':
			case 'h':
				std::cout<<"Allowed arguments:"<<std::endl;
				std::cout<<"\t-x\t--xml\t\tInput .xml file for SBNconfig"<<std::endl;
				return 0;
		}

	}

	/*************************************************************
	 *************************************************************
	 *		Main program Flow
	 ************************************************************
	 ************************************************************/

	TRandom3 *rangen = new TRandom3(0);



	//Load up one-d signal and background
	std::cout<<"Loading up good_bk/SBN_CV"<<std::endl;
	SBNspec oned_cv("SBN_CV",xml);
	//SBNspec oned_cv("good_bk/SBN_CV",xml);
	std::cout<<"Loading up SBN_SIG"<<std::endl;
	SBNspec oned_sig("SBN_SIG",xml);
	
	//Some normalization is require here then
	
	double myscale = 425.0/oned_cv.hist.at( oned_cv.map_hist["nu_uBooNE_nuevis_intrinsic"]).Integral() ;
	oned_cv.ScaleAll(myscale);	
	oned_sig.ScaleAll(myscale);


	oned_cv.calcFullVector();
	oned_sig.calcFullVector();
	oned_cv.compressVector();
	oned_sig.compressVector();
	

	std::cout<<"Loading up good_bk/covariance_matrix_ALL.root"<<std::endl;
	//Load up the Covariance matricies as generated by me!
	TFile *f = new TFile("covariance_matrix_ALL.root");
	//TFile *f = new TFile("good_bk/covariance_matrix_ALL.root");
	TMatrixT<double> m_oned =*(TMatrixT<double>*)f->Get("TMatrixT<double>;1");  
	TMatrixT<double> m_twod =*(TMatrixT<double>*)f->Get("TMatrixT<double>;4");  
	
	
	TFile *fsig = new TFile("covariance_matrix_ALL.root");
	std::cout<<"Loading up both TH2D's"<<std::endl;
	//These are the 2d histograms
	TH2D * h_twod_nue_cv = (TH2D*)fsig->Get("nuevis_cv");
	TH2D * h_twod_numu_cv = (TH2D*)fsig->Get("numuvis_cv");

	TH2D * h_twod_nue_sig = (TH2D*)fsig->Get("nuevis_sig");
	TH2D * h_twod_numu_sig = (TH2D*)fsig->Get("numuvis_sig");


	//and this are the 2d long vectors
	std::vector<double> vec_twod_cv;// (0,m_twod.GetNrows() );
	std::vector<double> vec_twod_sig;// (0, m_twod.GetNrows() );

	std::cout<<"..and filling the long vectors from TH2D"<<std::endl;
	std::cout<<h_twod_nue_cv->GetNbinsX()<<std::endl;

	//and to filll the long vectors up with the TH2D's
	for(int i=1; i<=h_twod_nue_cv->GetNbinsX();i++){
		for(int j=1; j<= h_twod_nue_cv->GetNbinsY();j++){
				vec_twod_cv.push_back(h_twod_nue_cv->GetBinContent(i,j) );	
				vec_twod_sig.push_back(h_twod_nue_sig->GetBinContent(i,j) );	
		}
	}
	for(int i=1; i<=h_twod_numu_cv->GetNbinsX();i++){
		for(int j=1; j<= h_twod_numu_cv->GetNbinsY();j++){
				vec_twod_cv.push_back(h_twod_numu_cv->GetBinContent(i,j) );	
				vec_twod_sig.push_back(h_twod_numu_sig->GetBinContent(i,j) );	
		}
	}
	std::cout<<"Few checks"<<std::endl;


	if(vec_twod_cv.size() != m_twod.GetNrows()){
		std::cout<<"FAILURE vec_twod is not the same size as the covariance mateix"<<std::endl;
		exit(EXIT_FAILURE);
	}

	TMatrixD invM2d = m_twod;
	


	for(int i =0; i< vec_twod_cv.size(); i++){
		for(int j =0; j< vec_twod_cv.size(); j++){
			invM2d(i,j) = invM2d(i,j)*vec_twod_cv.at(i)*vec_twod_cv.at(j) ;//
		//	invM2d(i,j)=0;
			if(i==j) invM2d(i,j) += vec_twod_cv.at(i)*vec_twod_cv.at(j) ;//
				
		}
	}

	invM2d.Invert();
		

	


	double chi2d = 0;
	for(int i =0; i< vec_twod_cv.size(); i++){
		for(int j =0; j< vec_twod_cv.size(); j++){
			//chi2d += pow(vec_twod_cv.at(i)-vec_twod_sig.at(i),2.0)*(1/vec_twod_cv.at(i));//
			chi2d += (vec_twod_cv.at(i)-vec_twod_sig.at(i))*invM2d(i,j)*(vec_twod_cv.at(j)-vec_twod_sig.at(j));
			//std::cout<<i<<" "<<j<<" "<<chi2d<<" M: "<<invM2d(i,j)<<" sig: "<<vec_twod_sig.at(i) <<" cv: "<<vec_twod_cv.at(i)<<" and sig: "<<vec_twod_sig.at(j) <<" cv: "<<vec_twod_cv.at(j)<<std::endl;

		}
	}
	std::cout<<"CHi^2 for 2D is: "<<chi2d<<std::endl;


	int nMC = 50000;

	//Ok to analyze full, create 4 chi^2 distograms, 2 for 1d and 2 for 2d each for each hypothesis.
	TH1D pdf_2d_sig("","",250,0,100);
	TH1D pdf_2d_cv("","",250,0,100);
	pdf_2d_sig.GetXaxis()->SetCanExtend(kTRUE);
	pdf_2d_cv.GetXaxis()->SetCanExtend(kTRUE);

	std::vector<double> ts = vec_twod_sig;
	std::vector<double> tc = vec_twod_cv;

	//is TMatrixD slowing me?
std::vector<std::vector<double>> vtmp(tc.size(), std::vector<double>(tc.size(),0));
		for(int i =0; i< tc.size(); i++){
			for(int j =0; j< tc.size(); j++){
				vtmp.at(i).at(j) = invM2d(i,j);
		}
	}
	

	for(int i=0; i< nMC; i++){
		if(i%200 ==0) std::cout<<"MC: "<<i<<"/"<<nMC<<std::endl;
		//first generate a random sig and cv
		for(int i=0; i< ts.size(); i++){
			ts.at(i) = rangen->Poisson(vec_twod_sig.at(i));
			tc.at(i) = rangen->Poisson(vec_twod_cv.at(i));
		//	if(ts.at(i) == 0){ std::cout<<"ZERO in sig @ "<<i<<" "<<vec_twod_sig.at(i)<<std::endl;}
		//	if(tc.at(i) == 0){ std::cout<<"ZERO in cv @ "<<i<<" "<<vec_twod_cv.at(i)<<std::endl;}
		}


		//then remake invM2d for that choice
/*
		if(false){
		TMatrixD invM2d_tmp = m_twod;
		for(int i =0; i< vec_twod_cv.size(); i++){
			for(int j =0; j< vec_twod_cv.size(); j++){
				invM2d_tmp(i,j) = m_twod(i,j)*tc.at(i)*tc.at(j);
				//invM2d_tmp(i,j)=0;
				if(i==j) invM2d_tmp(i,j) += tc.at(i)*tc.at(j) ;//
				
			}
		}
		invM2d_tmp.Invert();
		}
*/
		//Then calculate both chi62
		double chi2d_cv = 0;
		double chi2d_sig = 0;
		for(int i =0; i< tc.size(); i++){
			for(int j =0; j< tc.size(); j++){
				chi2d_sig += (ts.at(i)-vec_twod_cv.at(i))*vtmp.at(i).at(j)*(ts.at(j)-vec_twod_cv.at(j));
				chi2d_cv += (tc.at(i)-vec_twod_cv.at(i))*vtmp.at(i).at(j)*(tc.at(j)-vec_twod_cv.at(j));
			}
		}
	
		pdf_2d_cv.Fill(chi2d_cv);		
		pdf_2d_sig.Fill(chi2d_sig);		

	}

		

	
	//And now 1d spectrum
	SBNchi oned_chi_stat_only(oned_cv, m_oned);
	SBNchi oned_chi(oned_cv, m_oned);
	//oned_chi_stat_only.setStatOnly(true);

	TH1D pdf_1d_sig = oned_chi_stat_only.toyMC_varyInput(&oned_sig, nMC);
	TH1D pdf_1d_cv = oned_chi_stat_only.toyMC_varyInput(&oned_cv, nMC);
	


//	std::cout<<"X^2: "<<basechi<<" and pval "<<1.0-cdf( basechi, oned_sig.fullVec.size()  )<<" for "<<oned_sig.fullVec.size()<<" ndof."<<std::endl;

	
	//Plotting all of that

	TCanvas *call = new TCanvas();
	call->Divide(2,2);
	
	call->cd(1);
	pdf_1d_sig.SetLineColor(kBlue-6);
	pdf_1d_sig.SetLineWidth(2);
	//pdf_1d_sig.Scale(1.0/pdf_1d_sig.Integral());
	pdf_1d_sig.Draw("hist");	
	
	pdf_1d_cv.SetLineColor(kRed-6);
	pdf_1d_cv.SetLineWidth(2);
	//pdf_1d_cv.Scale(1.0/pdf_1d_cv.Integral());
	pdf_1d_cv.Draw("hist same");	

	TLegend *l1 = new TLegend(0.5,0.7,0.89,0.89);
	l1->AddEntry(&pdf_1d_sig,"1D Sig","l");
	l1->AddEntry(&pdf_1d_cv,"1D CV","l");
	l1->Draw();

	TPad *p3 = (TPad*) call->cd(3);
	p3->SetLogy();
	pdf_1d_sig.Draw("hist");	
	pdf_1d_cv.Draw("hist same");	

	
	call->cd(2);

	pdf_2d_cv.SetLineColor(kRed-6);
	pdf_2d_cv.SetLineWidth(2);
	//pdf_2d_cv.Scale(1.0/pdf_2d_cv.Integral());
	pdf_2d_cv.Draw("hist");	

	pdf_2d_sig.SetLineColor(kBlue-6);
	pdf_2d_sig.SetLineWidth(2);
	//pdf_2d_sig.Scale(1.0/pdf_2d_sig.Integral());
	pdf_2d_sig.Draw("hist same");	
	
	TLegend *l2 = new TLegend(0.5,0.7,0.89,0.89);
	l2->AddEntry(&pdf_2d_sig,"2D Sig","l");
	l2->AddEntry(&pdf_2d_cv,"2D CV","l");
	l2->Draw();



	TPad *p4 = (TPad*) call->cd(4);
	p4->SetLogy();
	pdf_2d_cv.Draw("hist");	
	pdf_2d_sig.Draw("hist same");	






	call->SaveAs("ans.pdf","pdf");


	return 0;




	/*****************************************
		everything below here is a bit old, cant say exactly whts going on
	******************************************/


	//This is correlated 1D fits here

	std::cout<<" oned_sig size : "<<oned_sig.fullVec.size()<<" m_oned "<<m_oned.GetNrows()<<" "<<m_oned.GetNcols()<<std::endl;
	//SBNchi oned_chi_stat_only(oned_cv, m_oned);
	//SBNchi oned_chi(oned_cv, m_oned);
	oned_chi_stat_only.setStatOnly(true);

	std::cout<<"TWO TEST: Finished initilising, now onto CalcChi."<<std::endl;	
	
	double basechi = oned_chi.CalcChi(&oned_cv);
	double basechi_stat_only = oned_chi_stat_only.CalcChi(&oned_sig);
//	int nMC = 20000;


	std::cout<<"Basechi stat only 1d: "<<basechi_stat_only<<std::endl;

//	TH1D mytoy = oned_chi.toyMC_varyCore(&oned_cv, 10000);
	TH1D mytoy_statonly = oned_chi_stat_only.toyMC_varyInput(&oned_cv, nMC);
	TH1D mytoy = oned_chi.toyMC_varyInput(&oned_cv, nMC);
	
	std::cout<<"X^2: "<<basechi<<" and pval "<<1.0-cdf( basechi, oned_sig.fullVec.size()  )<<" for "<<oned_sig.fullVec.size()<<" ndof."<<std::endl;

	
	TCanvas *ctoy = new TCanvas();
	ctoy->cd();

	mytoy.SetLineColor(kBlue-6);
	mytoy.SetLineWidth(2);
	mytoy.Scale(1.0/mytoy.Integral());
	mytoy.Draw("hist");	
	

	mytoy_statonly.SetLineColor(kRed-6);
	mytoy_statonly.SetLineWidth(2);
	mytoy_statonly.Scale(1.0/mytoy_statonly.Integral());
	mytoy_statonly.Draw("hist same");
	//TLine * l2 = new TLine(basechi,0,basechi,nMC/10);
	//l2->SetLineColor(kBlack);
	//l2->SetLineWidth(2);
	//l2->Draw();
	
	std::vector<double> val;
	std::vector<double> prob;

	for(double v=0; v<=100; v=v+0.25){
		val.push_back(v);
		double tp = ROOT::Math::chisquared_pdf(v, (double)oned_sig.fullVec.size());
		prob.push_back(tp );
	}

	TGraph *pr = new TGraph(val.size(), &val[0], &prob[0]);
	pr->SetLineWidth(2);
	pr->Draw("CP same");


	ctoy->SaveAs("toyMC.pdf","pdf");

	//******************************* Now onto a signal "data" sample *************************//
	SBNchi oned_chi_sig(oned_sig, m_oned);

	
	double basechisig = oned_chi_sig.CalcChi(&oned_cv);

	TH1D mytoy_sigcv = oned_chi_sig.toyMC_varyInput(&oned_cv, nMC);
	TH1D mytoy_sigsig = oned_chi_sig.toyMC_varyInput(&oned_sig, nMC);

	TCanvas * ctoysig = new TCanvas();
	ctoysig->Divide(1,2);
	TPad* p = (TPad*)ctoysig->cd(2);
	p->SetLogy();
	mytoy_sigcv.SetLineColor(kBlue-6);
	mytoy_sigcv.SetLineWidth(2);
	mytoy_sigcv.Scale(1.0/mytoy_sigcv.Integral());
	mytoy_sigcv.Draw("hist");	

	TH1D pcut = mytoy_sigcv;
	pcut.SetFillColor(kBlue-3);
	pcut.GetXaxis()->SetRangeUser(0,basechisig);

	mytoy_sigsig.SetLineColor(kRed-6);
	mytoy_sigsig.SetLineWidth(2);
	mytoy_sigsig.Scale(1.0/mytoy_sigsig.Integral());
	mytoy_sigsig.Draw("hist same");

	TH1D pcut2 = mytoy_sigsig;
	pcut2.SetFillColor(kRed-3);
	pcut2.GetXaxis()->SetRangeUser(basechisig,300);



	
	TLine * l3 = new TLine(basechisig,0,basechisig,nMC/10);
	l3->SetLineColor(kBlack);
	l3->SetLineWidth(2);
	l3->Draw();
	
	std::vector<double> valsig;
	std::vector<double> probsig;

	for(double v=0; v<=100; v=v+0.25){
		valsig.push_back(v);
		double tp = ROOT::Math::chisquared_pdf(v, (double)oned_sig.fullVec.size());
		probsig.push_back(tp);
	}

	TGraph *prsig = new TGraph(valsig.size(), &valsig[0], &probsig[0]);
	prsig->SetLineWidth(2);
	//prsig->Draw("CP same");

	ctoysig->cd(1);
	mytoy_sigcv.Draw("hist");
	mytoy_sigsig.Draw("hist same");
	l3->Draw();


	pcut.Draw("same hist");
	pcut2.Draw("same hist");
	
	TLegend *leg = new TLegend(0.69,0.89,0.69,0.89);
	leg->AddEntry(&mytoy_sigcv,"H0: Bkg Only","l");
	leg->AddEntry(&mytoy_sigsig,"H1: Bkg +Sig","l");
	leg->Draw();	

	ctoysig->SaveAs("toyMCsig.pdf","pdf");


	





	//Then calculate a chi^2



	return 0;



	std::string dict_location ="../../src/AutoDict_map_string__vector_double____cxx.so";
	gROOT->ProcessLine("#include <map>");
	gROOT->ProcessLine("#include <vector>");
	gROOT->ProcessLine("#include <string>");

	std::cout<<"Trying to load dictionary: "<<dict_location<<std::endl;
	gSystem->Load(  (dict_location).c_str());
	gStyle->SetOptStat(0);




	std::vector<double> bins_energy = {0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.0};
	std::vector<double> bins_angle = {-1,-0.9,-0.8,-0.7,-0.6,-0.5,-0.4,-0.3,-0.2,-0.1,0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0};


	std::cout<<"Init TH2's"<<std::endl;
	TH2D * h2_electron = new TH2D("h2_electron","h2_electron",bins_energy.size()-1, &bins_energy[0], bins_angle.size()-1,&bins_angle[0]);
	TH2D * h2_muon = new TH2D("h2_muon","h2_muon",bins_energy.size()-1, &bins_energy[0], bins_angle.size()-1,&bins_angle[0]);

	
	std::cout<<"Init TChain"<<std::endl;
	TChain * chain = new TChain("fittree");
	chain->Add("/home/mark/work/uBooNE/uboone_covariance_builder/rootfiles/fittree_nue_rw2.root");
	chain->Add("/home/mark/work/uBooNE/uboone_covariance_builder/rootfiles/fittree_bnb_rw2.root");

	int nuPDG;
	double leptonEnergy; 
	TLorentzVector * fLepMom;

	TBranch * bweight;

	chain->SetBranchAddress("nuPDG", &(nuPDG) );
	chain->SetBranchAddress("leptonEnergy", &(leptonEnergy) );
	chain->SetBranchAddress("leptonMom", &(fLepMom), &(bweight)  );

	TVector3 zaxis(0,0,1);

	
	std::cout<<"Chain is :"<<chain->GetEntries()<<" long"<<std::endl;
	double N_entries = 5000;
	//double N_entries = chain->GetEntries();

	for(int i=0; i< N_entries; i++){
		chain->GetEntry(i);
		double leptonAngle = cos(zaxis.Angle(fLepMom->Vect()));	

		if(i%2500==0) std::cout<<i<<"/"<<chain->GetEntries()<<std::endl;

		if(nuPDG == 12 || nuPDG == -12){
			h2_electron->Fill(leptonEnergy, leptonAngle );	

		}else if(nuPDG == 14 || nuPDG == -14){
			h2_muon->Fill(leptonEnergy, leptonAngle );	
		}

	}



TCanvas *c =  new TCanvas("c","c",1200,800);
c->Divide(2,1);

c->cd(1);
h2_electron->Draw("colz");

c->cd(2);
h2_muon->Draw("colz");

c->SaveAs("2d.pdf","pdf");




}
